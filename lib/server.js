// Generated by CoffeeScript 1.6.2
(function() {
  var basenameForExtensions, coffee, commonPath, compileDir, compileFile, compileJS, compilePath, csso, error, fullPaths, isAppModule, isDirectory, isFile, isHiddenFile, isNodeModule, isOJFile, isOJPage, isRelativeModule, isUnsupportedNodeModule, isWatchFile, isWatched, jsdom, ls, lsOJ, lsWatch, m, minifyCSSUnless, minifyJSUnless, minifySimpleJS, minifySimpleJSUnless, mkdirp, nodeModulePaths, nodeModulesLinkMap, oj, pass, readFileSync, relativePathWithEscaping, resolveLink, spaces, stripBOM, success, tabs, triggerWatched, trimArgList, uglifyjs, unwatchAll, unwatchDir, verbose, verbosity, wait, watchCache, watchDir, watchFile, watchParents, wrapCSMessage, wrapJS, wrapJSMessage, _, _buildFileCache, _buildNativeCache, _buildNativeCacheFromModuleList, _buildRequireCache, _clearRequireCacheRecord, _createHook, _escapeSingleQuotes, _first, _getRequiresInSource, _hookRequire, _i, _insertAt, _len, _length, _nativeModuleCode, _nodeModuleUnsupported, _nodeModulesSupported, _ojModuleCode, _ref, _rememberModule, _rememberModuleDependencies, _requireCache, _requireCacheToString, _restoreRequireCache, _saveRequireCache, _startsWith, _trim, _unhookRequire;

  _ref = ['path', 'fs', 'vm'];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    m = _ref[_i];
    global[m] = require(m);
  }

  _ = require('underscore');

  coffee = require('coffee-script');

  mkdirp = require('mkdirp');

  csso = require('csso');

  uglifyjs = require('uglify-js');

  jsdom = (require('jsdom')).jsdom;

  global.jQuery = global.$ = require('jquery');

  global.document = jsdom("<html><head></head><body></body></html>");

  global.window = document.createWindow();

  oj = require('./oj');

  oj.isClient = false;

  module.exports = oj;

  oj.codes = {
    reset: '\u001b[0m',
    black: '\u001b[30m',
    red: '\u001b[31m',
    green: '\u001b[32m',
    yellow: '\u001b[33m',
    blue: '\u001b[34m',
    magenta: '\u001b[35m',
    cyan: '\u001b[36m',
    gray: '\u001b[37m'
  };

  if (require.extensions) {
    coffee = require('coffee-script');
    stripBOM = function(c) {
      if (c.charCodeAt(0) === 0xFEFF) {
        return c.slice(1);
      } else {
        return c;
      }
    };
    wrapJS = function(code) {
      return "(function(){with(oj.sandbox){" + code + "}}).call(this);";
    };
    wrapCSMessage = function(message, filepath) {
      var _ref1, _ref2;

      return "" + ((_ref1 = oj.codes) != null ? _ref1.red : void 0) + "coffee-script error in " + filepath + ": " + message + ((_ref2 = oj.codes) != null ? _ref2.reset : void 0);
    };
    wrapJSMessage = function(message, filepath) {
      var _ref1, _ref2;

      return "" + ((_ref1 = oj.codes) != null ? _ref1.red : void 0) + "javascript error in " + filepath + ": " + message + ((_ref2 = oj.codes) != null ? _ref2.reset : void 0);
    };
    compileJS = function(module, code, filepath) {
      code = wrapJS(code);
      global.oj = oj;
      module._compile(code, filepath);
      return delete global.oj;
    };
    require.extensions['.oj'] = function(module, filepath) {
      var code, eJS;

      code = stripBOM(fs.readFileSync(filepath, 'utf8'));
      try {
        return compileJS(module, code, filepath);
      } catch (_error) {
        eJS = _error;
        eJS.message = wrapJSMessage(eJS.message, filepath);
        throw eJS;
      }
    };
    require.extensions['.ojc'] = function(module, filepath) {
      var code, eCoffee, eJS;

      code = stripBOM(fs.readFileSync(filepath, 'utf8'));
      try {
        code = coffee.compile(code, {
          bare: true
        });
      } catch (_error) {
        eCoffee = _error;
        eCoffee.message = wrapCSMessage(eCoffee.message, filepath);
        throw eCoffee;
      }
      try {
        return compileJS(module, code, filepath);
      } catch (_error) {
        eJS = _error;
        eJS.message = wrapJSMessage(eJS.message, filepath);
        throw eJS;
      }
    };
  }

  oj.watch = function(filesOrDirectories, options) {
    options = _.extend({}, options, {
      args: filesOrDirectories,
      watch: true
    });
    return oj.command(options);
  };

  oj.build = function(filesOrDirectories, options) {
    options = _.extend({}, options, {
      args: filesOrDirectories,
      watch: false
    });
    return oj.command(options);
  };

  verbosity = null;

  oj.command = function(options) {
    var fullPath, _j, _len1, _ref1, _ref2;

    if (options == null) {
      options = {};
    }
    verbosity = options.verbose || 1;
    if ((_ref1 = options.watch) == null) {
      options.watch = false;
    }
    if (!((_.isArray(options.args)) && options.args.length > 0)) {
      throw new Error('oj: no args found');
    }
    options.args = fullPaths(options.args, process.cwd());
    _ref2 = options.args;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      fullPath = _ref2[_j];
      compilePath(fullPath, options);
    }
  };

  compilePath = function(fullPath, options, cb) {
    var includeDir;

    if (options == null) {
      options = {};
    }
    if (cb == null) {
      cb = function() {};
    }
    if (isDirectory(fullPath)) {
      return compileDir(fullPath, options, cb);
    }
    includeDir = path.dirname(fullPath);
    compileFile(fullPath, includeDir, options, cb);
  };

  compileDir = function(dirPath, options, cb) {
    if (options == null) {
      options = {};
    }
    if (cb == null) {
      cb = function() {};
    }
    lsWatch(dirPath, options, function(err, files, dirs) {
      var d, f, _cb, _j, _k, _len1, _len2;

      if (options.watch) {
        for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
          d = dirs[_j];
          watchDir(d, dirPath, options);
        }
      }
      _cb = _.after(files.length, cb);
      for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
        f = files[_k];
        if (isOJPage(f)) {
          compileFile(f, dirPath, options, _cb);
        } else if (options.watch) {
          watchFile(f, dirPath, options);
          _cb();
        }
      }
    });
  };

  nodeModulePaths = function(from) {
    var dir, joiner, parts, paths, splitRe, tip, _j, _ref1;

    from = path.resolve(from);
    splitRe = (process.platform === 'win32' ? /[\/\\]/ : /\//);
    joiner = (process.platform === 'win32' ? '\\' : '/');
    paths = [];
    parts = from.split(splitRe);
    for (tip = _j = _ref1 = parts.length - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; tip = _ref1 <= 0 ? ++_j : --_j) {
      if (parts[tip] === 'node_modules') {
        continue;
      }
      dir = parts.slice(0, tip + 1).concat('node_modules').join(joiner);
      paths.push(dir);
    }
    return paths;
  };

  resolveLink = function(linkPath, out) {
    var e, newPath;

    try {
      newPath = fs.readlinkSync(linkPath);
      return resolveLink(newPath, newPath);
    } catch (_error) {
      e = _error;
    }
    return out;
  };

  nodeModulesLinkMap = function(fileDir) {
    var dir, dirs, e, linkPath, moduleName, modulePath, modules, out, _j, _k, _len1, _len2;

    dirs = nodeModulePaths(fileDir);
    out = {};
    for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
      dir = dirs[_j];
      try {
        modules = fs.readdirSync(dir);
        for (_k = 0, _len2 = modules.length; _k < _len2; _k++) {
          moduleName = modules[_k];
          modulePath = path.join(dir, moduleName);
          linkPath = resolveLink(modulePath);
          if (linkPath != null) {
            out[linkPath] = modulePath;
          }
        }
      } catch (_error) {
        e = _error;
      }
    }
    return out;
  };

  basenameForExtensions = function(p, arrayOfExt) {
    var ext, out, _j, _len1;

    if (arrayOfExt == null) {
      arrayOfExt = [];
    }
    out = path.basename(p);
    for (_j = 0, _len1 = arrayOfExt.length; _j < _len1; _j++) {
      ext = arrayOfExt[_j];
      out = path.basename(out, ext);
    }
    return out;
  };

  compileFile = function(filePath, includeDir, options, cb) {
    var cache, cacheLength, deltaTime, dirOut, eCompile, eRequire, fileBaseName, fileDir, fileOut, hookCache, hookOriginalCache, html, includedModules, isDebug, isMinify, moduleLinkMap, moduleParents, modules, ojml, outputDir, results, rootDir, scriptHtml, scriptIndex, startTime, styleHtml, styleIndex, subDir, timeStamp, _j, _len1, _ref1, _ref2;

    if (options == null) {
      options = {};
    }
    if (cb == null) {
      cb = function() {};
    }
    startTime = process.hrtime();
    _clearRequireCacheRecord('underscore');
    if (!isFile(filePath)) {
      throw new Error('oj: file not found');
    }
    isDebug = (_ref1 = options.debug) != null ? _ref1 : false;
    isMinify = (_ref2 = options.minify) != null ? _ref2 : false;
    includedModules = options.modules || [];
    includedModules = includedModules.concat(['oj']);
    rootDir = options.root || path.dirname(filePath);
    if (!isDirectory(rootDir)) {
      throw new Error('oj: root is not a directory');
    }
    if (options.watch) {
      watchFile(filePath, includeDir, options);
    }
    fileDir = path.dirname(filePath);
    outputDir = options.output || process.cwd();
    subDir = path.relative(includeDir, fileDir);
    fileBaseName = basenameForExtensions(filePath, ['.oj', '.ojc', 'ojlc']);
    fileOut = path.join(outputDir, subDir, fileBaseName + '.html');
    verbose(2, "compiling " + filePath);
    cache = {
      modules: {},
      files: {},
      "native": {}
    };
    moduleLinkMap = nodeModulesLinkMap(fileDir);
    modules = {};
    moduleParents = {};
    hookCache = {};
    hookOriginalCache = {};
    _hookRequire(modules, moduleLinkMap, hookCache, hookOriginalCache);
    _saveRequireCache();
    try {
      for (_j = 0, _len1 = includedModules.length; _j < _len1; _j++) {
        m = includedModules[_j];
        if (isNodeModule(m)) {
          _buildNativeCacheFromModuleList(cache["native"], [m], options.debug);
        } else {
          verbose(3, "including " + m);
          require(m);
        }
      }
      ojml = require(filePath);
    } catch (_error) {
      eRequire = _error;
      verbose(1, eRequire.message);
      _restoreRequireCache();
      _unhookRequire(modules, hookCache, hookOriginalCache);
      return;
    }
    _restoreRequireCache();
    _unhookRequire(modules, hookCache, hookOriginalCache);
    _rememberModuleDependencies(modules);
    try {
      results = oj.compile({
        debug: isDebug,
        minify: isMinify,
        html: 1,
        css: 0,
        styles: 1,
        dom: 0
      }, ojml);
      html = results.html;
      styleHtml = results.styles;
    } catch (_error) {
      eCompile = _error;
      error("runtime error in " + filePath + ": " + eCompile.message);
      return;
    }
    verbose(3, "caching " + filePath + " (" + (_length(modules)) + " files)");
    cache = _buildRequireCache(modules, cache, isDebug);
    cacheLength = _length(cache.files) + _length(cache.modules) + _length(cache["native"]);
    verbose(3, "serializing " + filePath + " (" + cacheLength + " files)");
    scriptHtml = _requireCacheToString(cache, filePath, isDebug);
    if (!results.tags.html) {
      error("validation error " + filePath + ": <html> tag is missing");
      return;
    } else if (!results.tags.head) {
      error("validation error " + filePath + ": <head> tag is missing");
      return;
    } else if (!results.tags.body) {
      error("validation error " + filePath + ": <body> tag is missing");
      return;
    }
    scriptIndex = html.lastIndexOf('</body>');
    html = _insertAt(html, scriptIndex, scriptHtml);
    styleIndex = html.lastIndexOf('</head>');
    html = _insertAt(html, styleIndex, styleHtml);
    dirOut = path.dirname(fileOut);
    if (mkdirp.sync(dirOut)) {
      verbose(3, "mkdir " + dirOut);
    }
    deltaTime = process.hrtime(startTime);
    timeStamp = " (" + (deltaTime[0] + Math.round(10000 * deltaTime[1] / 1000000000) / 10000) + " sec)";
    cache = null;
    hookCache = null;
    hookOriginalCache = null;
    return fs.writeFile(fileOut, html, function(err) {
      if (err) {
        error("file writing error " + filePath + ": " + err);
        return;
      }
      verbose(1, "compiled " + fileOut + timeStamp, 'cyan');
    });
  };

  watchCache = {};

  isWatched = function(fullPath) {
    return watchCache[fullPath] != null;
  };

  triggerWatched = function(fullPath) {
    var _ref1, _ref2;

    return (_ref1 = watchCache[fullPath]) != null ? (_ref2 = _ref1._events) != null ? typeof _ref2.change === "function" ? _ref2.change() : void 0 : void 0 : void 0;
  };

  watchParents = {};

  watchFile = function(filePath, includeDir, options) {
    var compileTimeout, e, prevStats, timeEpsilon, timeLast, watcher, _onWatch, _rewatch, _unwatch, _watchErr;

    if (options == null) {
      options = {};
    }
    if (isWatched(filePath)) {
      return;
    }
    prevStats = null;
    compileTimeout = null;
    _watchErr = function(e) {
      if (e.code === 'ENOENT') {
        try {
          _rewatch();
          return _compile();
        } catch (_error) {
          e = _error;
          verbose(2, "unwatching missing file: " + filePath, 'yellow');
          return _unwatch();
        }
      } else {
        throw e;
      }
    };
    timeLast = new Date(2000);
    timeEpsilon = 2;
    _onWatch = function() {
      var e;

      try {
        clearTimeout(compileTimeout);
        return compileTimeout = wait(0.025, function() {
          var parent, parents, timeNow, _j, _len1, _results;

          timeNow = new Date();
          if ((timeNow - timeLast) / 1000 < timeEpsilon) {
            return;
          }
          timeLast = timeNow;
          if (!isOJPage(filePath)) {
            parents = watchParents[filePath];
            if (parents != null) {
              _results = [];
              for (_j = 0, _len1 = parents.length; _j < _len1; _j++) {
                parent = parents[_j];
                _results.push(triggerWatched(parent));
              }
              return _results;
            }
          } else {
            return fs.stat(filePath, function(err, stats) {
              if (err) {
                return _watchErr(err);
              }
              verbose(2, "updating file " + filePath, 'yellow');
              return compileFile(filePath, includeDir, options);
            });
          }
        });
      } catch (_error) {
        e = _error;
        verbose(1, 'unknown watch error on #{filePath}');
        return _unwatch();
      }
    };
    try {
      verbose(2, "watching file " + filePath, 'yellow');
      watcher = fs.watch(filePath, _onWatch);
      watchCache[filePath] = watcher;
    } catch (_error) {
      e = _error;
      _watchErr(e);
    }
    _rewatch = function() {
      verbose(3, "rewatch file " + filePath, 'yellow');
      _unwatch();
      return watchCache[filePath] = watcher = fs.watch(filePath, _onWatch);
    };
    return _unwatch = function() {
      if (isWatched(filePath)) {
        watchCache[filePath].close();
      }
      return watchCache[filePath] = null;
    };
  };

  watchDir = function(dir, includeDir, options) {
    var compileTimeout, watcher;

    if (isWatched(dir)) {
      return;
    }
    compileTimeout = null;
    verbose(2, "watching directory " + dir + "/", 'yellow');
    watcher = fs.watch(dir, function(err) {
      verbose(2, "updating directory " + dir + "/", 'yellow');
      if (err && !isDirectory(dir)) {
        return unwatchDir(dir);
      }
      return lsOJ(dir, options, function(err, files, dirs) {
        var d, f, _j, _k, _len1, _len2, _results;

        for (_j = 0, _len1 = dirs.length; _j < _len1; _j++) {
          d = dirs[_j];
          if (!isWatched(d)) {
            watchDir(d);
          }
        }
        _results = [];
        for (_k = 0, _len2 = files.length; _k < _len2; _k++) {
          f = files[_k];
          if (!isWatched(f)) {
            _results.push(compileFile(f, includeDir, options));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
    });
    watchCache[dir] = watcher;
  };

  unwatchDir = function(dir) {
    verbose(2, "unwatching " + dir + "/", 'yellow');
    if (isWatched(dir)) {
      watchCache[dir].close();
    }
    watchCache[dir] = null;
  };

  unwatchAll = function() {
    var k, _j, _len1, _ref1, _results;

    verbose(2, "unwatching all files and directories", 'yellow');
    _ref1 = _.keys(watchCache);
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      k = _ref1[_j];
      if (watchCache[k] != null) {
        watchCache[k].close();
        _results.push(watchCache[k] = null);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  process.on('SIGINT', function() {
    verbose(1, "\n");
    unwatchAll();
    verbose(1, "oj exited successfully.", 'cyan');
    return process.exit();
  });

  success = function() {
    return process.exit(0);
  };

  tabs = function(count) {
    return Array(count + 1).join('\t');
  };

  spaces = function(count) {
    return Array(count + 1).join(' ');
  };

  verbose = function(level, message, color) {
    if (color == null) {
      color = 'reset';
    }
    if (verbosity >= level) {
      return console.log(oj.codes[color] + ("" + (spaces(4 * (level - 1))) + message) + oj.codes.reset);
    }
  };

  error = function(message) {
    var red, reset, _ref1, _ref2, _ref3, _ref4;

    red = (_ref1 = (_ref2 = oj.codes) != null ? _ref2.red : void 0) != null ? _ref1 : '';
    reset = (_ref3 = (_ref4 = oj.codes) != null ? _ref4.red : void 0) != null ? _ref3 : '';
    console.error("" + red + message + reset);
  };

  isFile = function(filePath) {
    var e;

    try {
      return (fs.statSync(filePath)).isFile();
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  isOJFile = function(filePath) {
    var ext;

    ext = path.extname(filePath);
    return ext === '.oj' || ext === '.ojc';
  };

  isOJPage = function(filePath) {
    var base, ext;

    ext = path.extname(filePath);
    base = path.basename(filePath);
    return (isOJFile(filePath)) && base[0] !== '_' && base.slice(0, 2) !== 'oj' && !isHiddenFile(filePath);
  };

  isWatchFile = function(filePath) {
    var ext;

    ext = path.extname(filePath);
    return (isOJFile(filePath)) || ext === '.js' || ext === '.coffee' || ext === '.json';
  };

  isHiddenFile = function(file) {
    return /^\.|~$/.test(file);
  };

  isDirectory = function(dirpath) {
    var e;

    try {
      return (fs.statSync(dirpath)).isDirectory();
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  relativePathWithEscaping = function(fullPath, relativeTo) {
    return _escapeSingleQuotes('/' + path.relative(relativeTo, fullPath));
  };

  fullPaths = function(relativePaths, dir) {
    return _.map(relativePaths, function(p) {
      return path.resolve(dir, p);
    });
  };

  commonPath = function(paths, seperator) {
    var common, ixCommon, ixPart, p, part, parts, _j, _k, _len1, _len2;

    if (seperator == null) {
      seperator = '/';
    }
    if (paths.length === 1) {
      return path.dirname(paths[0]);
    }
    common = paths[0].split(seperator);
    ixCommon = common.length;
    for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
      p = paths[_j];
      parts = p.split(seperator);
      for (ixPart = _k = 0, _len2 = parts.length; _k < _len2; ixPart = ++_k) {
        part = parts[ixPart];
        if (common[ixPart] !== part || ixPart > ixCommon) {
          break;
        }
      }
      ixCommon = Math.min(ixPart, ixCommon);
    }
    if (ixCommon === 1 && paths[0][0] === seperator) {
      return seperator;
    } else if (ixCommon === 0) {
      return null;
    }
    return (common.slice(0, ixCommon)).join(seperator);
  };

  lsOJ = function(paths, options, cb) {
    options = _.extend({}, {
      recurse: options.recurse,
      filter: function(f) {
        return isOJPage(f);
      }
    });
    ls(paths, options, function(err, results) {
      return cb(err, results.files, results.directories);
    });
  };

  lsWatch = function(paths, options, cb) {
    options = _.extend({}, {
      recurse: options.recurse,
      filter: function(f) {
        return isWatchFile(f);
      }
    });
    ls(paths, options, function(err, results) {
      return cb(err, results.files, results.directories);
    });
  };

  ls = function(paths, options, cb) {
    var breakIfDone, p, pending, _fn, _j, _len1, _ref1, _ref2, _ref3;

    if (!_.isArray(paths)) {
      paths = [paths];
    }
    if (_.isFunction(options)) {
      cb = options;
      options = {};
    }
    if (options == null) {
      options = {};
    }
    if ((_ref1 = options.results) == null) {
      options.results = {
        files: [],
        directories: []
      };
    }
    if ((_ref2 = options.recurse) == null) {
      options.recurse = false;
    }
    if ((_ref3 = options.filter) == null) {
      options.filter = function() {
        return true;
      };
    }
    pending = paths.length;
    breakIfDone = function() {
      if (pending === 0) {
        options.results.files = _.uniq(_.filter(options.results.files, options.filter));
        options.results.directories = _.uniq(options.results.directories);
        cb(null, options.results);
      }
    };
    _fn = function(p) {
      return fs.stat(p, function(err, stat) {
        if (!(stat != null ? stat.isDirectory() : void 0)) {
          options.results.files.push(p);
          return breakIfDone(--pending);
        } else {
          options.results.directories.push(p);
          return fs.readdir(p, function(errReadDir, paths_) {
            var p_, _fn1, _k, _len2;

            if (errReadDir) {
              return cb(errReadDir);
            }
            paths_ = fullPaths(paths_, p);
            pending += paths_.length;
            _fn1 = function(p_) {
              return fs.stat(p_, function(errStat, stat_) {
                if (errStat) {
                  return cb(errStat);
                }
                if (!(stat_ != null ? stat_.isDirectory() : void 0)) {
                  options.results.files.push(p_);
                  breakIfDone(--pending);
                  return;
                }
                if (options.recurse) {
                  ls(p_, options, function() {
                    return breakIfDone(--pending);
                  });
                } else {
                  breakIfDone(--pending);
                }
              });
            };
            for (_k = 0, _len2 = paths_.length; _k < _len2; _k++) {
              p_ = paths_[_k];
              _fn1(p_);
            }
            return breakIfDone(--pending);
          });
        }
      });
    };
    for (_j = 0, _len1 = paths.length; _j < _len1; _j++) {
      p = paths[_j];
      _fn(p);
    }
    breakIfDone();
  };

  readFileSync = function(filePath) {
    return fs.readFileSync(filePath, 'utf8');
  };

  wait = function(seconds, fn) {
    return setTimeout(fn, seconds * 1000);
  };

  trimArgList = function(v) {
    return _trim(v.split(','));
  };

  _trim = function(any) {
    var out;

    if (_.isString(any)) {
      return any.trim();
    } else if (_.isArray(any)) {
      out = _.map(any, function(v) {
        return v.trim();
      });
      return _.reject(out, (function(v) {
        return v === '' || v === null;
      }));
    } else {
      return any;
    }
  };

  _startsWith = function(strInput, strStart) {
    if (!((_.isString(strInput)) && (_.isString(strStart)))) {
      throw 'startsWith: argument error';
    }
    return strInput.length >= strStart.length && strInput.lastIndexOf(strStart, 0) === 0;
  };

  _escapeSingleQuotes = function(str) {
    return str.replace(/'/g, "\\'");
  };

  _insertAt = function(str, ix, substr) {
    return str.slice(0, ix) + substr + str.slice(ix);
  };

  _length = function(any) {
    return any.length || _.keys(any).length;
  };

  oj._minifyJS = function(js, options) {
    if (options == null) {
      options = {};
    }
    if (options.debug) {
      return js;
    } else if (options.minify) {
      return uglifyjs(js);
    } else {
      return js;
    }
  };

  minifyJSUnless = function(isDebug, filename, js) {
    if (isDebug) {
      return js;
    }
    if (filename) {
      verbose(4, "minified " + filename);
    }
    return oj._minifyJS(js);
  };

  minifySimpleJS = function(js, options) {
    js = js.replace(/\n/g, '');
    js.replace(/\s\s+/g, ' ');
    return js;
  };

  minifySimpleJSUnless = function(isDebug, js) {
    if (isDebug) {
      return js;
    }
    return minifySimpleJS(js);
  };

  oj._minifyCSS = function(css, options) {
    if (options == null) {
      options = {};
    }
    if (options.debug) {
      return css;
    } else if (options.minify) {
      return csso.justDoIt(css, true);
    } else {
      return css;
    }
  };

  minifyCSSUnless = function(isDebug, filename, css) {
    if (filename) {
      verbose(4, "minified " + filename);
    }
    if (isDebug) {
      return css;
    }
    return oj._minifyCSS(css);
  };

  _hookRequire = function(modules, moduleLinkMap, hookCache, hookOriginalCache) {
    var ext, handlers, hook;

    if (hookCache == null) {
      hookCache = {};
    }
    if (hookOriginalCache == null) {
      hookOriginalCache = {};
    }
    handlers = require.extensions;
    for (ext in handlers) {
      hook = hookCache[ext] || (hookCache[ext] = _createHook(ext, modules, moduleLinkMap, hookCache, hookOriginalCache));
      if (handlers[ext] !== hook) {
        hookOriginalCache[ext] = handlers[ext];
        handlers[ext] = hook;
      }
    }
  };

  _createHook = function(ext, modules, moduleLinkMap, hookCache, hookOriginalCache) {
    return function(module, filename) {
      var linkPath, moduleCompile, modulePath, rest;

      for (linkPath in moduleLinkMap) {
        modulePath = moduleLinkMap[linkPath];
        if (0 === filename.indexOf(linkPath)) {
          rest = filename.slice(linkPath.length);
          filename = modulePath + rest;
        }
      }
      if (!module.loaded) {
        _rememberModule(modules, filename, null, module.parent.filename);
        moduleCompile = module._compile;
        module._compile = function(code) {
          _rememberModule(modules, filename, code, module.parent.filename);
          moduleCompile.apply(this, arguments);
        };
      }
      hookOriginalCache[ext](module, filename);
      return _hookRequire(modules, moduleLinkMap, hookCache, hookOriginalCache);
    };
  };

  _unhookRequire = function(modules, hookCache, hookOriginalCache) {
    var ext, handlers;

    handlers = require.extensions;
    for (ext in handlers) {
      if (hookCache[ext] === handlers[ext]) {
        handlers[ext] = hookOriginalCache[ext];
      }
    }
    hookCache = null;
    hookOriginalCache = null;
  };

  _rememberModule = function(modules, filename, code, parent) {
    if (code) {
      verbose(3, "requiring " + filename);
    }
    return modules[filename] = _.defaults({
      code: code,
      parent: parent
    }, modules[filename] || {});
  };

  _rememberModuleDependencies = function(modules) {
    var filename, module, _ref1, _results;

    _results = [];
    for (filename in modules) {
      module = modules[filename];
      if ((_ref1 = watchParents[filename]) == null) {
        watchParents[filename] = [];
      }
      watchParents[filename].push(module.parent);
      _results.push(watchParents[filename] = _.unique(watchParents[filename]));
    }
    return _results;
  };

  _nodeModulesSupported = {
    oj: 1,
    assert: 1,
    console: 1,
    crypto: 1,
    events: 1,
    freelist: 1,
    path: 1,
    punycode: 1,
    querystring: 1,
    string_decoder: 1,
    tty: 1,
    url: 1,
    util: 1
  };

  _nodeModuleUnsupported = {
    child_process: 1,
    domain: 1,
    fs: 1,
    net: 1,
    os: 1,
    vm: 1,
    buffer: 1
  };

  isNodeModule = function(module) {
    return !!_nodeModulesSupported[module];
  };

  isUnsupportedNodeModule = function(module) {
    return !!_nodeModuleUnsupported[module];
  };

  isAppModule = function(module) {
    return (module.indexOf('/')) === -1;
  };

  isRelativeModule = function(module) {
    return (module.indexOf('/')) !== -1;
  };

  _requireCache = null;

  _saveRequireCache = function() {
    return _requireCache = _.clone(require.cache);
  };

  _restoreRequireCache = function() {
    var k, _results;

    _results = [];
    for (k in require.cache) {
      if (_requireCache[k] == null) {
        _results.push(delete require.cache[k]);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  _clearRequireCacheRecord = function(record) {
    return delete require.cache[require.resolve(record)];
  };

  _getRequiresInSource = function(code) {
    var match, out, r;

    r = new RegExp("require\\s*\\(?\\s*[\"']([^\"']+)", 'g');
    out = [];
    while (match = r.exec(code)) {
      out.push(match[1]);
    }
    return out;
  };

  _first = function(array, fn) {
    var x, y, _j, _len1;

    for (_j = 0, _len1 = array.length; _j < _len1; _j++) {
      x = array[_j];
      y = fn(x);
      if (y) {
        return y;
      }
    }
  };

  _buildRequireCache = function(modules, cache, isDebug) {
    var data, fileLocation, modulePrefixes, pathComponents;

    for (fileLocation in modules) {
      data = modules[fileLocation];
      if (data.code == null) {
        throw new Error('data.code is missing');
      }
      _buildFileCache(cache.files, fileLocation, data.code, isDebug);
      modulePrefixes = nodeModulePaths(fileLocation);
      pathComponents = _first(modulePrefixes, function(prefix) {
        var moduleMain, moduleName, modulePath;

        if (_startsWith(fileLocation, prefix + path.sep)) {
          modulePath = (fileLocation.slice(prefix.length + 1)).split(path.sep);
          moduleName = modulePath[0];
          moduleMain = modulePath.slice(1).join(path.sep);
          return {
            modulesDir: prefix,
            moduleName: moduleName,
            moduleMain: moduleMain,
            moduleParentPath: module.id
          };
        }
      });
      if (pathComponents) {
        if (!cache.modules[pathComponents.modulesDir]) {
          cache.modules[pathComponents.modulesDir] = {};
        }
        cache.modules[pathComponents.modulesDir][pathComponents.moduleName] = pathComponents.moduleMain;
      }
      _buildNativeCache(cache["native"], data.code, isDebug);
      verbose(4, "stored " + fileLocation);
    }
    delete cache.files[require.resolve('../lib/oj.js')];
    return cache;
  };

  _buildFileCache = function(_filesCache, fileName, code, isDebug) {
    return _filesCache[fileName] = minifyJSUnless(isDebug, fileName, code);
  };

  pass = 1;

  _buildNativeCache = function(nativeCache, code, isDebug) {
    var moduleNameList;

    moduleNameList = _getRequiresInSource(code);
    return _buildNativeCacheFromModuleList(nativeCache, moduleNameList, isDebug);
  };

  _buildNativeCacheFromModuleList = function(nativeCache, moduleNameList, isDebug) {
    var codeModule, moduleName;

    while (moduleName = moduleNameList.shift()) {
      if (nativeCache[moduleName]) {
        continue;
      }
      if (moduleName === 'oj') {
        nativeCache.oj = _ojModuleCode(isDebug);
      } else if (isUnsupportedNodeModule(moduleName)) {
        pass;
      } else if (isNodeModule(moduleName)) {
        codeModule = _nativeModuleCode(moduleName, isDebug);
        nativeCache[moduleName] = codeModule;
        moduleNameList = moduleNameList.concat(_getRequiresInSource(codeModule));
      } else {
        pass;
      }
    }
    return null;
  };

  _ojModuleCode = function(isDebug) {
    var code;

    code = readFileSync(path.join(__dirname, "../lib/oj.js"));
    return minifyJSUnless(isDebug, 'oj', code);
  };

  _nativeModuleCode = function(moduleName, isDebug) {
    var code;

    if (isDebug) {
      verbose(3, "found " + moduleName);
    }
    code = readFileSync(path.join(__dirname, "../modules/" + moduleName + ".js"));
    return minifyJSUnless(isDebug, moduleName, code);
  };

  _requireCacheToString = function(cache, filePath, isDebug) {
    var clientDir, clientFile, code, commonDir, moduleDir, moduleName, nameToMain, _fileToString, _files, _find, _modules, _modulesToString, _native, _nativeModuleToString, _ref1, _ref2, _ref3, _run;

    commonDir = commonPath(_.keys(cache.files));
    clientDir = _escapeSingleQuotes('/' + path.relative(commonDir, path.dirname(filePath)));
    clientFile = _escapeSingleQuotes('/' + basenameForExtensions(filePath, ['.ojc', '.oj', '.coffee', '.js']));
    _modulesToString = function(moduleDir, nameToMain) {
      moduleDir = relativePathWithEscaping(moduleDir, commonDir);
      return "M['" + moduleDir + "'] = " + (JSON.stringify(nameToMain)) + ";\n";
    };
    _nativeModuleToString = function(moduleName, code) {
      moduleName = _escapeSingleQuotes(moduleName);
      return "F['" + moduleName + "'] = (function(module,exports){(function(process,global,__dirname,__filename){" + code + "})(P,G,'/','" + moduleName + "');});\n";
    };
    _fileToString = function(filePath, code) {
      var fileDir, fileName;

      filePath = relativePathWithEscaping(filePath, commonDir);
      fileDir = path.dirname(filePath);
      fileName = path.basename(filePath);
      return "F['" + filePath + "'] = (function(module,exports){(function(require,process,global,__dirname,__filename){" + code + "})(RR('" + filePath + "'),P,G,'" + fileDir + "','" + fileName + "');});\n";
    };
    _modules = "";
    _ref1 = cache.modules;
    for (moduleDir in _ref1) {
      nameToMain = _ref1[moduleDir];
      _modules += _modulesToString(moduleDir, nameToMain);
    }
    _files = "";
    _ref2 = cache.files;
    for (filePath in _ref2) {
      code = _ref2[filePath];
      _files += _fileToString(filePath, code);
      verbose(4, "serialized `" + filePath + "`");
    }
    _native = "";
    _ref3 = cache["native"];
    for (moduleName in _ref3) {
      code = _ref3[moduleName];
      _native += _nativeModuleToString(moduleName, code);
      verbose(4, "serialized '" + moduleName + "'");
    }
    _run = minifySimpleJSUnless(isDebug, "function run(f){\n    if(R[f] != null)\n      return R[f];\n    var eo = {},\n      mo = {exports: eo};\n    if(typeof F[f] != 'function')\n      throw new Error(\"file not found (\" + f + \")\");\n    F[f](mo,eo);\n    return R[f] = mo.exports;\n  }");
    _find = minifySimpleJSUnless(isDebug, "function find(m,f){\n    var r, dir, dm, ext, ex, i;\n\n    if (F[m] && !m.match(/\\//)) {\n      return m;\n    }\n\n    if (!!m.match(/\\//)) {\n      r = oj._pathResolve(f, oj._pathJoin(oj._pathDirname(f), m));\n      ext = ['.ojc','.oj','.coffee','.js','.json'];\n      for(i = 0; i < ext.length; i++){\n        ex = ext[i];\n        if(F[r+ex])\n          return r+ex;\n      }\n    } else {\n      dir = oj._pathDirname(f);\n      while(true) {\n        dm = oj._pathJoin(dir, 'node_modules');\n        if(M[dm] && M[dm][m])\n          return oj._pathJoin(dm, m, M[dm][m]);\n        if(dir == '/')\n          break;\n        dir = oj._pathResolve(dir, '..');\n      }\n    }\n    throw new Error(\"module not found (\" + m + \")\");\n  }");
    return "<script>\n\n// Generated with oj v" + oj.version + "\n(function(){ var F = {}, M = {}, R = {}, P, G, RR;\n\n" + _modules + _files + _native + "\nP = {cwd: function(){return '/';}};\nG = {process: P,Buffer: {}};\nRR = function(f){\n  return function(m){\n    return run(find(m, f));\n  };\n  " + _run + "\n  " + _find + "\n};\n\nrequire = RR('" + (path.join(clientDir, clientFile)) + "');\noj = require('oj');\noj.load('" + clientFile + "');\n\n}).call(this);\n\n</script>";
  };

  oj.express = function() {
    return console.log("express called");
  };

}).call(this);
